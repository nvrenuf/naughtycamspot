---
import { withBase } from '../utils/links';

interface Props {
  href_pages: string;
  href_prod: string;
  label: string;
  class?: string;
}

const {
  href_pages,
  href_prod,
  label,
  class: className = '',
  ...rest
} = Astro.props as Props & Record<string, unknown>;

const baseUrl = typeof import.meta.env.BASE_URL === 'string' ? import.meta.env.BASE_URL : '/';
const isPagesFlag = typeof import.meta.env.IS_PAGES === 'string' ? import.meta.env.IS_PAGES === 'true' : false;
const isPagesBuild = isPagesFlag || baseUrl !== '/';
const rawHref = (isPagesBuild ? href_pages : href_prod) ?? '';
const trimmedHref = typeof rawHref === 'string' ? rawHref.trim() : '';

if (!trimmedHref) {
  throw new Error('LinkCTA requires a non-empty href.');
}

const resolvedHref = trimmedHref.startsWith('http') ? trimmedHref : withBase(trimmedHref);
const isExternal = /^https?:\/\//i.test(resolvedHref);

const {
  rel: relFromProps,
  target: targetFromProps,
  ...restProps
} = rest as Record<string, unknown>;

const relTokens = new Set<string>();

if (typeof relFromProps === 'string' && relFromProps.trim().length > 0) {
  relFromProps
    .split(/\s+/)
    .filter(Boolean)
    .forEach((token) => relTokens.add(token));
}

if (isExternal) {
  relTokens.add('nofollow');
  relTokens.add('noopener');
}

const finalRel = relTokens.size > 0 ? Array.from(relTokens).join(' ') : undefined;
const finalTarget = isExternal ? '_blank' : (typeof targetFromProps === 'string' ? targetFromProps : undefined);

const baseClass =
  'inline-flex items-center justify-center rounded-full px-6 py-3 text-xs font-semibold uppercase tracking-[0.3em] transition hover:-translate-y-1';
const combinedClass = [baseClass, className].filter(Boolean).join(' ');
const hasSlot = Astro.slots.has('default');
---
<a {...restProps} class={combinedClass} href={resolvedHref} target={finalTarget} rel={finalRel}>
  {hasSlot ? <slot /> : label}
</a>
